Funcionamiento y lógica del sistema de prioridades
- Cada proceso en el sistema se le asigna una prioridad( inicializada en 0) y un boost( inicializada en 1)
- Tanto Prioridad como Boost funcionan juntos, mientras mas baja es la prioridad, mas alto será el privilegio del proceso para ejecutarse
- Cada vez que un proceso nuevo entra al sistema, se le incrementala prioridad a todos los procesos que se pueden ejecutar:
    *Aca se aplican las limitaciones del enunciado, ajustamos el campo de prioridad con prioridad += boost
    *si la prioridad llega a 9, el boost cambia a -1 para reducir su prioridad
    *Si la prioridad llega a 0, el boost vuelve al valor de 1 para aumentar la prioridad
- Luego, el scheduler selecciona el proceso con mayor prioridad para ejecutarse, que en este caso es el proceso con un valor numérico menor), con esto  ,nos aseguramos que todos los procesos tengan una oportunidad justa de ejecucióm.



MODIFICACIONES REALIZadas

1. Se modifico proc.h, que es la estructura de proceso, añadiendo los casos de prioridad y boost ( int prioridad, int proceso)
2. En proc.c se inicializo prioridad en 0 y boost en 1 cuando se crea un proceso, esto se añadio en la funcion de allocproc
3. Luego en el mismo archivo, se añadio una logica en scheduler para ajustar la prioridad y boost ed cada proceso, donde la logica selecciona el proceso con menor valor de prioridad para ejecutarse. Esta seleccion se implemetna buscando el proceso con la prioridad
mas baja en cada ciclo
4. Se creo un archivo de prueba.c que sirve para validar el funcionamiento de prioridades ejecutando 20 procesos, mostrando el orden de ejecución de esto
5. Se añadio prueba al Makefile, especificamente a los uprogs
6. se compiló con make qemu.



Dificultades:
- hacer que los procesos se ejecuten primero según su prioridad
- los mensajes de ejecucion se imprimian de la siguiente manera:
    EjecutaEnjdeo cpruotcanedsoo pr Eoj4ec
    cesutoEa jec5nu
    dtoa npdroo pceroscoe Esjeoc6 u
    tando pE7rjo
    ecutcandoEej sepcruoo ctando p8roc
    eesso oE 1j90e
    cutandoEE jjprecuoecucttesoaando  np11ro
    cdesoEoj  ep1r2o
    cescuto E1aj3endc
    out procaeEnsod jo preo1ce4csu
    ota nd1Eoj ep5cr
    ocesou tE1jec6uantan
esto se arreglo utilizando un mecanismo de ajuste de prioridad con exit para que el sistema espere a que el hiijo termine antes de crear el siguiente proceso, inteté usar sleep pero no funcionó
-Tuve problemas con git, pues intente realizar el commit y se borro todo el xv6, pero realicé un reset y un push desde la rama de la tarea 1 y ingrese nuevamente los archivos de manera manual, creando una rama sin conflictos
